#include <avr/io.h>  // รวมไลบรารี AVR IO สำหรับการนิยามรีจิสเตอร์

int main(void)
{
    // ตั้งค่า PD6 (OC0A) และ PD5 (OC0B) เป็นขาออก
    DDRD |= (1 << DDD6) | (1 << DDD5);  // ตั้งค่า PD6 และ PD5 เป็นขาออกโดยการตั้งบิต 6 และ 5 ในรีจิสเตอร์ DDRD

    // กำหนดค่า Timer 0 ให้เป็นโหมด Phase Correct PWM (WGM02:0 = 001)
    TCCR0A = (1 << WGM00);  // ตั้งบิต WGM00 ใน TCCR0A เพื่อเปิดใช้งานโหมด Phase Correct PWM
    TCCR0B = (0 << WGM02);  // ตรวจสอบให้แน่ใจว่าบิต WGM02 ใน TCCR0B ถูกล้าง (เป็น 0 โดยค่าเริ่มต้น)

    // ตั้งค่าโหมดไม่ผกผันสำหรับ OC0A และ OC0B
    TCCR0A |= (1 << COM0A1) | (0 << COM0A0);  // ตั้งบิต COM0A1 และล้างบิต COM0A0 สำหรับโหมดไม่ผกผันของ OC0A
    TCCR0A |= (1 << COM0B1) | (0 << COM0B0);  // ตั้งบิต COM0B1 และล้างบิต COM0B0 สำหรับโหมดไม่ผกผันของ OC0B

    // ตั้งค่าตัวแบ่งความถี่เป็น 1 (CS00:02 = 001)
    TCCR0B = (1 << CS00);  // ตั้งบิต CS00 ใน TCCR0B เพื่อใช้การไม่แบ่งความถี่ (prescaler = 1)

    // ตั้งค่าตัวนับเริ่มต้น
    TCNT0 = 0;  // กำหนดค่าเริ่มต้นให้ Timer/Counter0 เป็น 0

    // ตั้งค่ารีจิสเตอร์เปรียบเทียบเอาท์พุตสำหรับรอบการทำงานที่ต้องการ
    OCR0A = 51;   // ตั้งค่ารีจิสเตอร์เปรียบเทียบเอาท์พุต A เป็น 51 สำหรับรอบการทำงาน 20% ของ 510 (51/255 ≈ 0.2)
    OCR0B = 179;  // ตั้งค่ารีจิสเตอร์เปรียบเทียบเอาท์พุต B เป็น 179 สำหรับรอบการทำงาน 70% ของ 510 (179/255 ≈ 0.7)

    // ลูปที่ไม่มีที่สิ้นสุด
    while (1)  // ลูปที่ไม่มีที่สิ้นสุดเพื่อให้โปรแกรมทำงานต่อไป
    {
        // ไม่มีอะไรต้องทำที่นี่, สัญญาณ PWM ถูกสร้างอัตโนมัติ
    }

    return 0;  // คำสั่ง return แต่ไม่เคยถูกเรียกใช้งานในลูปที่ไม่มีที่สิ้นสุดนี้
}
